import PQueue from 'p-queue';
import { LlmGenerateFilesResponse } from '../codegen/llm-runner.js';
import { BuildResultStatus } from '../workers/builder/builder-types.js';
import { Environment } from '../configuration/environment.js';
import {
  AttemptDetails,
  LlmContextFile,
  RootPromptDefinition,
} from '../shared-interfaces.js';
import { DEFAULT_MAX_REPAIR_ATTEMPTS } from '../configuration/constants.js';
import { ProgressLogger } from '../progress/progress-logger.js';
import { runBuild } from './build-worker.js';
import { repairAndBuild } from './build-repair.js';
import { EvalID, Gateway } from './gateway.js';
import { serveAndTestApp } from './serve-testing-worker.js';
import { BrowserAgentTaskInput } from '../testing/browser-agent/models.js';

/**
 * Attempts to build the code that an LLM generated. If the build fails, attempts
 * to fix the breakage and build again.
 *
 * @param evalID ID of the eval being attempted for build.
 * @param gateway Gateway.
 * @param model Model to be used for repair generation requests.
 * @param env Environment that is currently being run.
 * @param rootPromptDef Definition of the root prompt.
 * @param directory Directory on disk to which to write.
 * @param contextFiles Files that should be passed as context to the LLM.
 * @param initialOutputFiles Initial files generated by the LLM.
 * @param usage Usage data from the initial LLM run.
 * @param attemptDetails Array tracking information about the current build attempt.
 * @param skipScreenshots Whether to skip taking screenshots of the app.
 * @param skipAxeTesting Whether or not to skip Axe testing of the app.
 * @param abortSignal Signal to fire when the build should be aborted.
 * @param workerConcurrencyQueue Concurrency queue for controlling parallelism of worker invocations (as they are more expensive than LLM calls).
 */
export async function attemptBuild(
  evalID: EvalID,
  gateway: Gateway<Environment>,
  model: string,
  env: Environment,
  rootPromptDef: RootPromptDefinition,
  directory: string,
  contextFiles: LlmContextFile[],
  initialResponse: LlmGenerateFilesResponse,
  attemptDetails: AttemptDetails[],
  abortSignal: AbortSignal,
  workerConcurrencyQueue: PQueue,
  progress: ProgressLogger,
  skipScreenshots: boolean,
  skipAxeTesting: boolean,
  enableAutoCsp: boolean,
  userJourneyAgentTaskInput: BrowserAgentTaskInput | undefined,
  maxAxeRepairAttempts: number
) {
  const initialBuildResult = await runBuild(
    evalID,
    gateway,
    directory,
    env,
    rootPromptDef,
    abortSignal,
    workerConcurrencyQueue,
    progress
  );
  let repairAttempts = 0;
  const maxRepairAttempts = gateway.shouldRetryFailedBuilds(evalID)
    ? DEFAULT_MAX_REPAIR_ATTEMPTS
    : 0;

  const initialAttempt = {
    outputFiles: initialResponse.files,
    usage: {
      ...{ inputTokens: 0, outputTokens: 0, totalTokens: 0 },
      ...initialResponse.usage,
    },
    reasoning: initialResponse.reasoning,
    buildResult: initialBuildResult,
    serveTestingResult: null,
    attempt: 0,
  };
  attemptDetails.push(initialAttempt);

  let lastAttempt: AttemptDetails = initialAttempt;
  while (
    lastAttempt.buildResult.status !== BuildResultStatus.SUCCESS &&
    repairAttempts < maxRepairAttempts
  ) {
    repairAttempts++;
    progress.log(
      rootPromptDef,
      'build',
      `Trying to repair app build (attempt #${repairAttempts + 1})`
    );

    const attempt = await repairAndBuild(
      evalID,
      gateway,
      model,
      env,
      rootPromptDef,
      directory,
      lastAttempt.outputFiles,
      lastAttempt.buildResult.message,
      'There are the following build errors:',
      contextFiles,
      abortSignal,
      workerConcurrencyQueue,
      repairAttempts,
      progress
    );

    attemptDetails.push(attempt);
    lastAttempt = attempt;
  }

  if (lastAttempt.buildResult.status === BuildResultStatus.SUCCESS) {
    // Now that we got a working app, try to serve it and collect
    // findings from the running app.
    lastAttempt.serveTestingResult = await serveAndTestApp(
      evalID,
      gateway,
      directory,
      env,
      rootPromptDef,
      workerConcurrencyQueue,
      abortSignal,
      progress,
      skipScreenshots,
      skipAxeTesting,
      enableAutoCsp,
      userJourneyAgentTaskInput
    );
  }

  // Attempt to repair axe testing. This only runs when the last build
  // passed and serving did run. Note: By default, we don't run axe repair
  // attempts as it's not commonly done by LLMs in the ecosystem.
  let axeRepairAttempts = 0;
  while (
    lastAttempt.serveTestingResult &&
    (lastAttempt.serveTestingResult.axeViolations?.length ?? 0) > 0 &&
    axeRepairAttempts < maxAxeRepairAttempts
  ) {
    axeRepairAttempts++;
    progress.log(
      rootPromptDef,
      'build',
      `Trying to repair axe accessibility violations (attempt #${axeRepairAttempts + 1})...`
    );

    const axeViolationsError = JSON.stringify(
      lastAttempt.serveTestingResult.axeViolations,
      null,
      2
    );

    progress.log(rootPromptDef, 'error', 'Found Axe accessibility violations');

    const attempt = await repairAndBuild(
      evalID,
      gateway,
      model,
      env,
      rootPromptDef,
      directory,
      lastAttempt.outputFiles,
      axeViolationsError,
      'There are the following accessibility errors from axe accessibility violations:',
      contextFiles,
      abortSignal,
      workerConcurrencyQueue,
      axeRepairAttempts + repairAttempts,
      progress
    );

    attemptDetails.push(attempt);
    lastAttempt = attempt;

    // If we somehow introduced build errors via the Axe repair loop, we abort
    // further a11y repairs and capture the failed build. This is useful insight
    // as LLMs seem to regress when asked to repair a11y violations.
    if (attempt.buildResult.status !== BuildResultStatus.SUCCESS) {
      break;
    }

    // Re-run serving & tests after Axe repair.
    // This allows us to check if we fixed the violations.
    attempt.serveTestingResult = await serveAndTestApp(
      evalID,
      gateway,
      directory,
      env,
      rootPromptDef,
      workerConcurrencyQueue,
      abortSignal,
      progress,
      skipScreenshots,
      skipAxeTesting,
      enableAutoCsp,
      userJourneyAgentTaskInput
    );

    if (attempt.serveTestingResult.axeViolations?.length === 0) {
      progress.log(
        rootPromptDef,
        'success',
        `Successfully fixed all Axe accessibility violations`
      );
    }
  }

  return {
    buildResult: lastAttempt.buildResult,
    serveTestingResult: lastAttempt.serveTestingResult,
    outputFiles: lastAttempt.outputFiles,
    repairAttempts,
    axeRepairAttempts,
  };
}
